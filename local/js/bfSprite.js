// Generated by CoffeeScript 1.6.3
(function() {
  var Buff, DamageText, Debuff, Dot, Hot, Shadow, Status,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DamageText = (function(_super) {
    __extends(DamageText, _super);

    function DamageText(host, type, value) {
      var _this = this;
      DamageText.__super__.constructor.call(this, 0, 0);
      this.value = "-" + value;
      switch (type) {
        case "normal":
          this.color = "rgb(235, 88, 88)";
          break;
        case "heal":
          this.color = "green";
          this.value = "+" + value;
      }
      this.y = -host.height + host.anchor.y + 50;
      this.host = host;
      this.transform.scale = 1;
      this.transform.opacity = 0;
      this.host.drawQueueAdd(this);
      this.animate({
        y: "-=150",
        "transform.opacity": 1
      }, "fast", function() {
        return _this.fadeOut("normal", function() {
          return _this.host.drawQueueRemove(_this);
        });
      });
    }

    DamageText.prototype.draw = function(context) {
      context.font = 'bold 40pt Calibri';
      context.fillStyle = this.color;
      return context.fillText(this.value, 30, -10);
    };

    return DamageText;

  })(Drawable);

  Shadow = (function(_super) {
    __extends(Shadow, _super);

    function Shadow(host, radius) {
      Shadow.__super__.constructor.call(this, 0, 110);
      this.host = host;
      this.host.drawQueueAddBefore(this);
      this.radius = radius || 70;
    }

    Shadow.prototype.draw = function(context) {
      context.scale(1, 0.35);
      context.fillStyle = "rgba(20,20,20,0.2)";
      context.beginPath();
      context.arc(0, 0, this.radius, 0, Math.PI * 2, true);
      context.closePath();
      return context.fill();
    };

    return Shadow;

  })(Drawable);

  Status = (function(_super) {
    __extends(Status, _super);

    function Status(host, data) {
      Status.__super__.constructor.apply(this, arguments);
      this.couter = 0;
      this.host = host;
      this.turn = data.turn || 3;
    }

    Status.prototype.nextTurn = function() {
      this.couter += 1;
      if (this.couter > this.turn) {
        return this.remove();
      }
    };

    Status.prototype.remove = function() {
      this.host.removeStatus(this);
      return this.host = null;
    };

    return Status;

  })(EventEmitter);

  Buff = (function(_super) {
    __extends(Buff, _super);

    function Buff(data) {
      Buff.__super__.constructor.apply(this, arguments);
    }

    Buff.prototype.handleAttackDamage = function(damage) {
      return damage;
    };

    Buff.prototype.handleOnAttacakDamage = function(damage) {
      return damage;
    };

    return Buff;

  })(Status);

  Debuff = (function(_super) {
    __extends(Debuff, _super);

    function Debuff(data) {
      Debuff.__super__.constructor.apply(this, arguments);
    }

    Debuff.prototype.handleAttackDamage = function(damage) {
      return damage;
    };

    Debuff.prototype.handleOnAttacakDamage = function(damage) {
      return damage;
    };

    return Debuff;

  })(Status);

  Dot = (function(_super) {
    __extends(Dot, _super);

    function Dot(data) {
      Dot.__super__.constructor.apply(this, arguments);
    }

    Dot.prototype.active = function() {};

    return Dot;

  })(Status);

  Hot = (function(_super) {
    __extends(Hot, _super);

    function Hot(data) {
      Hot.__super__.constructor.apply(this, arguments);
    }

    Hot.prototype.active = function() {};

    return Hot;

  })(Status);

  window.BfEffectSprite = (function(_super) {
    __extends(BfEffectSprite, _super);

    function BfEffectSprite(bf, spriteData, from, to) {
      var _this = this;
      BfEffectSprite.__super__.constructor.call(this, 0, 0, spriteData);
      this.transform.scale = 1.3;
      this.z = 999;
      if (this.movements.fly) {
        this.x = from.x + (from.castPositionX || 0);
        this.y = from.y + (from.castPositionY || 0);
        bf.drawQueueAdd(this);
        this.useMovement("fly", true);
        this.animate({
          x: to.x + 50,
          y: to.y + 100
        }, "normal", function() {
          _this.emit("active");
          _this.animate({
            "transform.scale": 2
          }, "fast");
          return _this.useMovement("active", function() {
            _this.destroy();
            return bf.drawQueueRemove(_this);
          });
        });
      } else {
        this.x = 0;
        this.y = 0;
        to.drawQueueAdd(this);
        this.useMovement("active", function() {
          console.log("movement end");
          _this.emit("destroy");
          to.drawQueueRemove(_this);
          if (!_this.destroyed) {
            _this.emit("active");
            return _this.destroy();
          }
        });
        this.on("keyFrame", function() {
          _this.emit("active");
          return _this.destroy();
        });
      }
    }

    BfEffectSprite.prototype.draw = function() {
      return BfEffectSprite.__super__.draw.apply(this, arguments);
    };

    return BfEffectSprite;

  })(Sprite);

  window.BattlefieldSprite = (function(_super) {
    __extends(BattlefieldSprite, _super);

    function BattlefieldSprite(bf, x, y, spriteData, originData) {
      var _this = this;
      BattlefieldSprite.__super__.constructor.call(this, x, y, spriteData);
      this.originData = originData;
      this.statusValue = this.originData.statusValue;
      this.shadow = new Shadow(this, this.spriteData.shadowRadius);
      this.drawQueueAddBefore(this.shadow);
      this.bf = bf;
      this.hp = null;
      this.icon = spriteData.icon;
      this.status = {
        buffs: {},
        debuffs: {},
        dots: {},
        hots: {}
      };
      this.flipOverEffects = {};
      this.dead = false;
      this.speedItem = bf.menu.addSpeedItem(this);
      this.speedItem.on("active", function() {
        return _this.act();
      });
    }

    BattlefieldSprite.prototype.act = function() {
      var name, obj, status, type, _ref, _results;
      this.bf.paused = true;
      this.emit("act");
      _ref = this.status;
      _results = [];
      for (type in _ref) {
        obj = _ref[type];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (name in obj) {
            status = obj[name];
            _results1.push(status.nextTurn());
          }
          return _results1;
        })());
      }
      return _results;
    };

    BattlefieldSprite.prototype.handleAttackDamage = function(damage) {
      var buff, debuff, name, _ref, _ref1;
      _ref = this.status.buffs;
      for (name in _ref) {
        buff = _ref[name];
        buff.handleAttackDamage(damage);
      }
      _ref1 = this.status.debuffs;
      for (name in _ref1) {
        debuff = _ref1[name];
        debuff.handleAttackDamage(damage);
      }
      return damage;
    };

    BattlefieldSprite.prototype.handleHurtDamage = function(damage) {
      var buff, debuff, name, _ref, _ref1;
      _ref = this.status.buffs;
      for (name in _ref) {
        buff = _ref[name];
        buff.handleAttackDamage(damage);
      }
      _ref1 = this.status.debuffs;
      for (name in _ref1) {
        debuff = _ref1[name];
        debuff.handleAttackDamage(damage);
      }
      return damage;
    };

    BattlefieldSprite.prototype.handleHealQuantity = function(heal) {
      return heal;
    };

    BattlefieldSprite.prototype.attackFire = function(target, index, length) {};

    BattlefieldSprite.prototype.useSpell = function(activeType, sourceSupplies, target, callback) {
      var name, originData, rate, spellData;
      name = sourceSupplies.name;
      originData = sourceSupplies.originData;
      if (!originData[activeType]) {
        return console.error("no " + activeType + " data in supplies", sourceSupplies);
      }
      spellData = originData[activeType];
      if (spellData.sameWithActive) {
        rate = spellData.rate || 0.3;
        spellData = originData.active;
        spellData.rate = rate;
      }
      if (activeType === "defense") {
        this.isDefensed = true;
        this.flipOverEffects[name] = spellData;
        if (callback) {
          return callback();
        }
      } else {
        return this.castSpell(sourceSupplies, spellData, target, callback);
      }
    };

    BattlefieldSprite.prototype.getSpellDamage = function(sourceSupplies, spellData) {
      var damage, damageRate, rate, type;
      if (!spellData.damage) {
        return console.error("no damage data in spelldata", spellData);
      }
      damage = {};
      damageRate = spellData.damage;
      for (type in damageRate) {
        rate = damageRate[type];
        damage[type] = sourceSupplies.traitValue * rate;
      }
      console.log("spell damage", damageRate, damage);
      return damage;
    };

    BattlefieldSprite.prototype.getSpellHeal = function(sourceSupplies, spellData) {
      var healRate;
      if (!spellData.heal) {
        return console.error("no heal data in spelldata", spellData);
      }
      healRate = spellData.heal;
      return healRate * sourceSupplies.traitValue;
    };

    BattlefieldSprite.prototype.castSpell = function(sourceSupplies, spellData, target, callback) {
      var damage, effect, f, heal, name, self, sprite, spriteData,
        _this = this;
      name = spellData.name;
      this.bf.displaySpellName(spellData.name);
      self = this;
      switch (spellData.type) {
        case "attack":
          sprite = spellData.sprite || "energyBall";
          damage = this.handleAttackDamage(this.getSpellDamage(sourceSupplies, spellData));
          f = function() {
            return target.onHurt(self, damage);
          };
          break;
        case "heal":
          sprite = spellData.sprite || "buff";
          heal = this.handleHealQuantity(this.getSpellHeal(sourceSupplies, spellData));
          f = function() {
            return target.onHeal(self, heal);
          };
          break;
        case "dot":
          sprite = spellData.sprite || "debuff";
          f = function() {
            return target.status.dots[name] = new Dot(this, spellData);
          };
          break;
        case "hot":
          sprite = spellData.sprite || "buff";
          f = function() {
            return target.status.hots[name] = new Hot(this, spellData);
          };
          break;
        case "buff":
          sprite = spellData.sprite || "buff";
          f = function() {
            return target.status.buffs[name] = new Buff(this, spellData);
          };
          break;
        case "debuff":
          sprite = spellData.sprite || "debuff";
          f = function() {
            return target.status.debuffs[name] = new Debuff(this, spellData);
          };
      }
      spriteData = this.db.sprites.effects.get(sprite);
      effect = new BfEffectSprite(this.bf, spriteData, this, target);
      effect.on("destroy", function() {
        _this.bf.paused = false;
        if (callback) {
          return callback();
        }
      });
      return effect.on("active", f);
    };

    BattlefieldSprite.prototype.onHeal = function(from, heal) {
      return this.hp += heal;
    };

    BattlefieldSprite.prototype.onHurt = function(from, damage) {
      var effect, type, value, _results,
        _this = this;
      console.log("" + name + " on attack", damage);
      this.bf.camera.shake("fast");
      window.AudioManager.play("hurt");
      if (this.isDefensed) {
        effect = new BlendLayer(this, "rgba(238, 215, 167, 0.6)");
      } else {
        effect = new BlendLayer(this, "rgba(240,30,30,0.8)");
      }
      effect.transform.opacity = 1;
      effect.flash(150, function() {
        return _this.drawQueueRemove(effect);
      });
      this.handleHurtDamage(damage);
      _results = [];
      for (type in damage) {
        value = damage[type];
        new DamageText(this, type, value);
        _results.push(this.hp -= value);
      }
      return _results;
    };

    BattlefieldSprite.prototype.removeStatus = function(targetStatus) {
      var name, obj, status, type, _ref;
      _ref = this.status;
      for (type in _ref) {
        obj = _ref[type];
        for (name in obj) {
          status = obj[name];
          if (status === targetStatus) {
            delete obj[name];
            return true;
          }
        }
      }
      return false;
    };

    BattlefieldSprite.prototype.draw = function(context) {
      return BattlefieldSprite.__super__.draw.apply(this, arguments);
    };

    BattlefieldSprite.prototype.tick = function(tickDelay) {
      if (!this.bf.paused && !this.dead) {
        return this.speedItem.tick(tickDelay);
      }
    };

    return BattlefieldSprite;

  })(Sprite);

}).call(this);
