// Generated by CoffeeScript 1.6.3
(function() {
  var Buff, DamageText, Debuff, Dot, EffectStatus, FlipOverEffect, Hot, Shadow, Status, StatusMark, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DamageText = (function(_super) {
    __extends(DamageText, _super);

    function DamageText(host, type, value, startY) {
      var _this = this;
      if (startY == null) {
        startY = 0;
      }
      DamageText.__super__.constructor.call(this, 0, 0);
      value = parseInt(value);
      switch (type) {
        case "miss":
          this.color = "white";
          this.value = "未命中";
          break;
        case "normal":
          this.color = "rgb(255,150,80)";
          this.value = "- " + value + " 通常伤害";
          break;
        case "fire":
          this.color = "#99130E";
          this.value = "- " + value + " 火焰伤害";
          break;
        case "ice":
          this.color = "#4AAAB8";
          this.value = "- " + value + " 冰霜伤害";
          break;
        case "impact":
          this.color = "#9C7013";
          this.value = "- " + value + " 冲击伤害";
          break;
        case "minus":
          this.color = "#444CA2";
          this.value = "- " + value + " 负能量伤害";
          break;
        case "spirit":
          this.color = "#912CB1";
          this.value = "- " + value + " 灵能伤害";
          break;
        case "heal":
          this.color = "#59a84c";
          this.value = "+ " + value + " 生命回复";
      }
      this.y = -host.height + host.anchor.y + 50 + startY;
      this.host = host;
      this.transform.scale = 1;
      this.transform.opacity = 0;
      this.host.drawQueueAdd(this);
      this.animate({
        y: "-=150",
        "transform.opacity": 1
      }, "fast", function() {
        return _this.fadeOut("slow", function() {
          return _this.host.drawQueueRemove(_this);
        });
      });
    }

    DamageText.prototype.onDraw = function() {
      if (this.host.transform.scaleX < 0) {
        this.transform.scaleX = -1;
      } else {
        this.transform.scaleX = 1;
      }
      return DamageText.__super__.onDraw.apply(this, arguments);
    };

    DamageText.prototype.draw = function(context) {
      context.font = 'bold 38px sans-serif';
      context.fillStyle = "black";
      context.fillText(this.value, -100, 0);
      context.fillStyle = this.color;
      return context.fillText(this.value, -100, 1);
    };

    return DamageText;

  })(Drawable);

  Shadow = (function(_super) {
    __extends(Shadow, _super);

    function Shadow(host, radius) {
      Shadow.__super__.constructor.call(this, 0, 110);
      this.host = host;
      this.host.drawQueueAddBefore(this);
      this.radius = radius || 70;
    }

    Shadow.prototype.draw = function(context) {
      context.scale(1, 0.35);
      context.fillStyle = "rgba(20,20,20,0.2)";
      context.beginPath();
      context.arc(0, 0, this.radius, 0, Math.PI * 2, true);
      context.closePath();
      return context.fill();
    };

    return Shadow;

  })(Drawable);

  StatusMark = (function(_super) {
    __extends(StatusMark, _super);

    function StatusMark(status) {
      var counter, dy, height, name, obj, type, width, x, y, _ref;
      this.status = status;
      this.host = status.host;
      this.name = status.spellData.name;
      width = 120;
      height = 35;
      counter = 0;
      _ref = this.host.status;
      for (type in _ref) {
        obj = _ref[type];
        for (name in obj) {
          status = obj[name];
          counter += 1;
        }
      }
      dy = counter * height + 5;
      switch (status.spellData.type) {
        case "buff":
        case "hot":
        case "heal":
          this.color = "#59a84c";
          this.textColor = "black";
          break;
        default:
          this.color = "#555";
          this.textColor = "white";
      }
      if (this.host.name === "player") {
        x = 150;
        y = -200 + dy;
      } else {
        x = -150;
        y = -100 + dy;
      }
      StatusMark.__super__.constructor.call(this, x, y, width, height);
      this.transform.opacity = 0.6;
      this.textX = -38;
      this.textY = 5;
    }

    StatusMark.prototype.draw = function(context) {
      var remainTurn;
      context.fillStyle = this.color;
      context.beginPath();
      Utils.drawRoundRect(context, -this.width / 2, -this.height / 2, this.width, this.height, 5);
      context.closePath();
      context.fill();
      context.font = "bold 18px sans-serif";
      context.fillStyle = this.textColor;
      remainTurn = this.status.turn - this.status.counter;
      return context.fillText("" + this.name + " " + remainTurn, this.textX, this.textY);
    };

    return StatusMark;

  })(Drawable);

  Status = (function(_super) {
    __extends(Status, _super);

    function Status(host, sourceSupplies, spellData) {
      var _this = this;
      Status.__super__.constructor.apply(this, arguments);
      this.sourceSupplies = sourceSupplies;
      this.traitValue = this.sourceSupplies.traitValue;
      this.traitValueLevel = this.sourceSupplies.traitValueLevel;
      this.spellData = spellData;
      this.counter = 0;
      this.name = spellData.name;
      this.host = host;
      this.turn = Math.round(this.getRealValue(spellData.turn)) || 5;
      this.listeners = [];
      this.initMark();
      this.addHostListener("act", function() {
        return _this.nextTurn();
      });
    }

    Status.prototype.initMark = function() {
      this.statusMark = new StatusMark(this);
      return this.host.drawQueueAdd(this.statusMark);
    };

    Status.prototype.nextTurn = function() {
      this.counter += 1;
      if (this.counter >= this.turn) {
        console.log("remove status");
        return this.remove();
      }
    };

    Status.prototype.remove = function() {
      var l, _i, _len, _ref;
      console.log("status  " + this.name + " removed");
      this.host.removeStatus(this);
      this.host.drawQueueRemove(this.statusMark);
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        this.host.off(l.event, l.f);
      }
      return this.host = null;
    };

    Status.prototype.getRealValue = function(value) {
      var max, min;
      if (!value) {
        return false;
      }
      if (!(value instanceof Array)) {
        return value;
      }
      max = value[1];
      min = value[0];
      return min + (this.traitValueLevel / 6) * (max - min);
    };

    Status.prototype.addHostListener = function(event, func) {
      this.host.on(event, func);
      return this.listeners.push({
        event: event,
        func: func
      });
    };

    return Status;

  })(EventEmitter);

  FlipOverEffect = (function(_super) {
    __extends(FlipOverEffect, _super);

    function FlipOverEffect() {
      _ref = FlipOverEffect.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    FlipOverEffect.prototype.remove = function() {
      FlipOverEffect.__super__.remove.apply(this, arguments);
      return delete this.host.flipOverEffects[this.name];
    };

    return FlipOverEffect;

  })(Status);

  Dot = (function(_super) {
    __extends(Dot, _super);

    function Dot(host, sourceSupplies, spellData) {
      var type, value, _ref1,
        _this = this;
      Dot.__super__.constructor.apply(this, arguments);
      this.rate = spellData.rate || 1;
      this.damage = {};
      console.log(spellData.damage);
      _ref1 = spellData.damage;
      for (type in _ref1) {
        value = _ref1[type];
        this.damage[type] = value * this.traitValue * this.rate;
      }
      console.log(this.damage);
      this.addHostListener("act", function() {
        console.log("fuck");
        return _this.active();
      });
    }

    Dot.prototype.active = function() {
      return this.host.onHurt(null, this.damage);
    };

    return Dot;

  })(Status);

  Hot = (function(_super) {
    __extends(Hot, _super);

    function Hot(host, sourceSupplies, spellData) {
      var _this = this;
      Hot.__super__.constructor.apply(this, arguments);
      this.rate = spellData || 1;
      this.heal = data.heal * this.traitValue * this.rate;
      this.addHostListener("act", function() {
        return _this.active();
      });
    }

    Hot.prototype.active = function() {
      return this.host.onHeal(this.heal);
    };

    return Hot;

  })(Status);

  EffectStatus = (function(_super) {
    __extends(EffectStatus, _super);

    function EffectStatus(host, sourceSupplies, spellData) {
      var _this = this;
      EffectStatus.__super__.constructor.apply(this, arguments);
      console.log("fuck fuck fuck");
      console.log(spellData);
      if (spellData.effect) {
        console.log("enter");
        this.addHostListener("updateStatusValue", function(statusValue) {
          return _this.onEffect(statusValue);
        });
        console.log(this.host);
      }
    }

    EffectStatus.prototype.onEffect = function(statusValue) {
      var type, value, _ref1;
      console.log("on effect fire");
      _ref1 = this.spellData.effect;
      for (type in _ref1) {
        value = _ref1[type];
        if (!statusValue[type]) {
          switch (type) {
            case "accuracy":
              statusValue[type] = 95;
              break;
            case "resistance":
              statusValue[type] = 10;
              break;
            case "iceDef":
            case "fireDef":
            case "impactDef":
            case "spiritDef":
            case "minusDef":
              statusValue[type] = 10;
          }
        }
        value = this.getRealValue(value);
        statusValue[type] *= value;
      }
      return statusValue;
    };

    return EffectStatus;

  })(Status);

  Buff = (function(_super) {
    __extends(Buff, _super);

    function Buff() {
      _ref1 = Buff.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Buff;

  })(EffectStatus);

  Debuff = (function(_super) {
    __extends(Debuff, _super);

    function Debuff() {
      _ref2 = Debuff.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return Debuff;

  })(EffectStatus);

  window.BfEffectSprite = (function(_super) {
    __extends(BfEffectSprite, _super);

    function BfEffectSprite(bf, spriteData, from, to) {
      var _this = this;
      BfEffectSprite.__super__.constructor.call(this, 0, 0, spriteData);
      this.transform.scale = 1.3;
      this.z = 999;
      this.host = null;
      if (this.movements.fly) {
        this.x = from.x + (from.castPositionX || 0);
        this.y = from.y + (from.castPositionY || 0);
        this.host = bf;
        this.useMovement("fly", true);
        this.animate({
          x: to.x + 50,
          y: to.y + 100
        }, "normal", function() {
          _this.emit("active");
          _this.animate({
            "transform.scale": 2
          }, "fast");
          return _this.useMovement("active", function() {
            return _this.destroy();
          });
        });
      } else {
        this.x = 0;
        this.y = 0;
        this.host = to;
        this.useMovement("active", function() {
          console.log("movement end");
          _this.emit("active");
          return _this.destroy();
        });
        this.on("keyFrame", function() {
          return _this.emit("active");
        });
      }
      this.host.drawQueueAdd(this);
    }

    BfEffectSprite.prototype.destroy = function() {
      BfEffectSprite.__super__.destroy.apply(this, arguments);
      return this.host.drawQueueRemove(this);
    };

    BfEffectSprite.prototype.draw = function() {
      return BfEffectSprite.__super__.draw.apply(this, arguments);
    };

    return BfEffectSprite;

  })(Sprite);

  window.BattlefieldSprite = (function(_super) {
    __extends(BattlefieldSprite, _super);

    function BattlefieldSprite(bf, x, y, spriteData, originData) {
      var _this = this;
      BattlefieldSprite.__super__.constructor.call(this, x, y, spriteData);
      this.originData = originData;
      this.statusValue = this.originData.statusValue;
      this.realStatusValue = Utils.clone(this.statusValue);
      this.shadow = new Shadow(this, this.spriteData.shadowRadius);
      this.drawQueueAddBefore(this.shadow);
      this.bf = bf;
      this.hp = this.realStatusValue.hp;
      this.icon = spriteData.icon;
      this.status = {
        buffs: {},
        debuffs: {},
        dots: {},
        hots: {},
        flipOver: {}
      };
      this.dead = false;
      this.speedItem = bf.menu.addSpeedItem(this);
      this.speedItem.on("active", function() {
        return _this.act();
      });
    }

    BattlefieldSprite.prototype.updateStatusValue = function() {
      this.realStatusValue = Utils.clone(this.statusValue);
      this.emit("updateStatusValue", this.realStatusValue);
      return console.log("update status value", this.realStatusValue);
    };

    BattlefieldSprite.prototype.act = function() {
      this.bf.paused = true;
      this.updateStatusValue();
      console.log("act", this);
      return this.emit("act", this.realStatusValue);
    };

    BattlefieldSprite.prototype.handleFlipOverEffectes = function(damage, from) {
      var data, name, target, _ref3, _results;
      _ref3 = this.status.flipOver;
      _results = [];
      for (name in _ref3) {
        data = _ref3[name];
        switch (data.spellData.type) {
          case "buff":
          case "heal":
          case "hot":
            target = this;
            break;
          default:
            target = from;
        }
        _results.push(this.castSpell(data.sourceSupplies, data.spellData, target));
      }
      return _results;
    };

    BattlefieldSprite.prototype.handleAttackDamage = function(damage) {
      var accuracy, type, value;
      accuracy = this.realStatusValue.accuracy || 80;
      if (Math.random() * 100 > accuracy) {
        for (type in damage) {
          value = damage[type];
          delete damage[type];
        }
        console.log("击空");
      } else {
        this.emit("damage", damage);
        console.log("攻击");
      }
      return damage;
    };

    BattlefieldSprite.prototype.handleHurtDamage = function(damage) {
      var def, defName, miss, statusValue, type, value;
      statusValue = this.realStatusValue;
      miss = statusValue.miss || 5;
      if (Math.random() * 100 < miss) {
        console.log("未闪避");
        for (type in damage) {
          value = damage[type];
          delete damage[type];
        }
        return damage;
      }
      console.log("闪避", damage);
      this.emit("hurt", damage, statusValue);
      if (this.isDefensed) {
        def = statusValue.def * 2;
      } else {
        def = statusValue.def;
      }
      for (type in damage) {
        value = damage[type];
        if (type === "normal") {
          damage[type] -= def;
        } else {
          damage[type] -= def / 2;
        }
        defName = "" + type + "Def";
        if (statusValue[defName]) {
          value -= statusValue[defName];
        }
        if (damage[type] <= 0) {
          damage[type] = 1;
        }
      }
      return damage;
    };

    BattlefieldSprite.prototype.defense = function() {
      return this.bf.paused = false;
    };

    BattlefieldSprite.prototype.attackFire = function(target, index, length) {};

    BattlefieldSprite.prototype.attack = function() {};

    BattlefieldSprite.prototype.useSpell = function(activeType, sourceSupplies, target) {
      var effect, name, originData, rate, spellData, spriteData,
        _this = this;
      name = sourceSupplies.name;
      originData = sourceSupplies.originData;
      if (!originData[activeType]) {
        return console.error("no " + activeType + " data in supplies", sourceSupplies);
      }
      spellData = originData[activeType];
      if (spellData.sameWithActive) {
        rate = spellData.rate || 0.3;
        name = spellData.name;
        spellData = originData.active;
        spellData.rate = rate;
        spellData.name = name;
      }
      if (activeType === "defense") {
        this.addStatus("flipOver", new FlipOverEffect(this, sourceSupplies, spellData));
        spriteData = this.db.sprites.effects.get("buff");
        effect = new BfEffectSprite(this.bf, spriteData, this, target);
        return effect.once("active", function() {
          return _this.defense();
        });
      } else {
        return this.castSpell(sourceSupplies, spellData, target, function() {
          _this.bf.paused = false;
          return _this.bf.menu.hideActionBtns();
        });
      }
    };

    BattlefieldSprite.prototype.getSpellDamage = function(sourceSupplies, spellData) {
      var damage, damageRate, globalRate, rate, type;
      if (!spellData.damage) {
        return console.error("no damage data in spelldata", spellData);
      }
      damage = {};
      damageRate = spellData.damage;
      globalRate = spellData.rate || 1;
      for (type in damageRate) {
        rate = damageRate[type];
        damage[type] = sourceSupplies.traitValue * rate * globalRate;
      }
      console.log("spell damage", damageRate, damage);
      return damage;
    };

    BattlefieldSprite.prototype.getSpellHeal = function(sourceSupplies, spellData) {
      var globalRate, healRate;
      if (!spellData.heal) {
        return console.error("no heal data in spelldata", spellData);
      }
      globalRate = spellData.rate || 1;
      healRate = spellData.heal * globalRate;
      return healRate * sourceSupplies.traitValue;
    };

    BattlefieldSprite.prototype.castSpell = function(sourceSupplies, spellData, target, callback) {
      var damage, effect, f, heal, name, self, sprite, spriteData,
        _this = this;
      console.log("castSpell", arguments);
      name = spellData.name;
      this.bf.displaySpellName(spellData.name);
      self = this;
      switch (spellData.type) {
        case "attack":
          sprite = spellData.sprite || "energyBall";
          damage = this.getSpellDamage(sourceSupplies, spellData);
          this.emit("damage", damage);
          f = function() {
            return target.onHurt(self, damage);
          };
          break;
        case "heal":
          sprite = spellData.sprite || "buff";
          heal = this.getSpellHeal(sourceSupplies, spellData);
          this.emit("heal", heal);
          f = function() {
            return target.onHeal(self, heal);
          };
          break;
        case "dot":
          sprite = spellData.sprite || "debuff";
          f = function() {
            return target.addStatus("dot", new Dot(target, sourceSupplies, spellData));
          };
          break;
        case "hot":
          sprite = spellData.sprite || "buff";
          f = function() {
            return target.addStatus("hot", new Hot(target, sourceSupplies, spellData));
          };
          break;
        case "buff":
          sprite = spellData.sprite || "buff";
          f = function() {
            console.log("active");
            target.addStatus("buff", new Buff(target, sourceSupplies, spellData));
            return target.updateStatusValue();
          };
          break;
        case "debuff":
          sprite = spellData.sprite || "debuff";
          f = function() {
            target.addStatus("debuff", new Debuff(target, sourceSupplies, spellData));
            return target.updateStatusValue();
          };
      }
      spriteData = this.db.sprites.effects.get(sprite);
      spellData.spriteData = spriteData;
      effect = new BfEffectSprite(this.bf, spriteData, this, target);
      effect.once("active", function() {
        f();
        if (callback) {
          return callback();
        }
      });
      if (spellData.next) {
        return this.castSpell(sourceSupplies, spellData.next, target, callback);
      } else {

      }
    };

    BattlefieldSprite.prototype.onHeal = function(from, heal) {
      this.hp += heal;
      new BlendLayer(this, "rgba(180,250,200,0.6)", "flash", "fast");
      return new DamageText(this, "heal", heal);
    };

    BattlefieldSprite.prototype.onHurt = function(from, damage) {
      var effect, idx, text, type, value;
      console.log("" + this.name + " on hurt", damage);
      this.bf.camera.shake("fast");
      window.AudioManager.play("hurt");
      if (from) {
        this.handleFlipOverEffectes(damage, from);
      }
      damage = this.handleHurtDamage(damage);
      idx = 0;
      for (type in damage) {
        value = damage[type];
        if (!value) {
          continue;
        }
        text = new DamageText(this, type, value, 50 * idx + 1);
        this.hp -= value;
        idx += 1;
      }
      if (idx === 0) {
        return new DamageText(this, "miss");
      } else {
        if (this.isDefensed) {
          return effect = new BlendLayer(this, "rgba(238, 215, 167, 0.6)", "flash", "fast");
        } else {
          return effect = new BlendLayer(this, "rgba(240,30,30,0.8)", "flash", "fast");
        }
      }
    };

    BattlefieldSprite.prototype.addStatus = function(type, status) {
      switch (type) {
        case "buff":
          type = "buffs";
          break;
        case "debuff":
          type = "debuffs";
          break;
        case "dot":
          type = "dots";
          break;
        case "hot":
          type = "hots";
          break;
        case "flipOver":
          type = "flipOver";
      }
      if (this.status[type][status.name]) {
        this.status[type][status.name].remove();
      }
      return this.status[type][status.name] = status;
    };

    BattlefieldSprite.prototype.removeStatus = function(targetStatus) {
      var name, obj, status, type, _ref3;
      _ref3 = this.status;
      for (type in _ref3) {
        obj = _ref3[type];
        for (name in obj) {
          status = obj[name];
          if (status === targetStatus) {
            delete obj[name];
            return true;
          }
        }
      }
      return false;
    };

    BattlefieldSprite.prototype.die = function() {
      var name, obj, status, type, _ref3, _results;
      _ref3 = this.status;
      _results = [];
      for (type in _ref3) {
        obj = _ref3[type];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (name in obj) {
            status = obj[name];
            _results1.push(status.remove());
          }
          return _results1;
        })());
      }
      return _results;
    };

    BattlefieldSprite.prototype.draw = function(context) {
      return BattlefieldSprite.__super__.draw.apply(this, arguments);
    };

    BattlefieldSprite.prototype.tick = function(tickDelay) {
      if (!this.bf.paused && !this.dead) {
        return this.speedItem.tick(tickDelay);
      }
    };

    return BattlefieldSprite;

  })(Sprite);

}).call(this);
